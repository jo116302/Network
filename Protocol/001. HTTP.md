> # HTTP/1

- 하이퍼텍스트
  - 제약 없는 방식으로 서로 연결되어 사람이 읽을 수 있는 정보를 의미
  - 정보가 반드시 텍스트 형태일 필요는 없음을 의미

>> ## HTTP/0.9 

- GET 하나의 메서드만 존재
- 헤더가 없음
- 텍스트만 처리 가능

>> ## HTTP/1.0

- HTTP/0.9 보다 추가된 기능
  - Header
  - Response codes (응답 코드)
  - Redirect (리다이렉트)
  - Error (오류)
  - Conditional requests (조건부 요청)
  - Encoding (콘텐츠 인코딩), (Compression (압축))
  - Request Method (다양해진 요청 메서드 존재)

- 한계점
  - Header 필수가 아님
  - 지속적인 요청사이에 연결 유지 기능이 없음
  - 캐싱 옵션 빈약

>> ## HTTP/1.1

- 20년 넘게 명맥을 유지해왔음
- HTTP/1.0 보다 개선 또는 추가된 기능
  - Header 필수 항목 - 하나의 IP 주소로 다수의 웹 프로퍼티 제공 가능
  - 새 연결 지시자를 사용하면 웹 서버는 응답 후 연결 유지 가능 (TCP 연결을 유지할 수 있어 재수립 시간 절약 및 성능 향상)
  - Cacheability 헤더의 확장
  - OPTIONS 메서드
  - Upgrade 헤더
  - Range 요청
  - Transfer-Encoding 압축
  - 파이프라이닝
    - 클라이언트의 요청을 동시에 전송 가능 기술
    - 문제점
      - 순서대로 응답
      - 한 요청이 장시간 처리가 필요한 경우 HOL (Head Of Line Blocking) 현상 발생

>> ## HTTP/1의 부각되는 문제점

- [HTTP/1의 네트워크 연결 매커니즘](https://security-song.tistory.com/15)

>>> ### [HOL 블로킹](https://withbundo.blogspot.com/2021/02/httphol-head-of-line-blocking.html)

- 통신 시간을 줄이기 위한 동시요청을 구현하려고 병렬기능을 위한 HTTP/1에서 Pipelining 이라는 기능 사용
- 하지만 결과적으로는 한번에 하나의 응답을 전송 순으로 수신
- 가장 먼저 받아야될 응답의 딜레이가 발생한다면 후순위 응답을 받지 못하는 현상을 의미
  <br />![image](https://user-images.githubusercontent.com/81629923/121767346-a642ee00-cb92-11eb-9192-ab090d175161.png)<br /> 참고 링크6 참고하기
- [TCP HOL Blocking](https://zigispace.net/970)
  - HOL Blocking 유형 : HTTP의 HOL Blocking, TCP의 HOL Blocking 

>>> ### TCP의 비효율적 사용

- HTTP/1은 단발성 연결이기 때문에 TCP의 혼잡 제어를 위한 slow-start의 기능의 최적 성능을 이끌어내지 못할 가능성이 있음
- 패킷 하나에는 최대 1,460 byte의 데이터 저장하여 전송 가능

>>> ### 비대한 메시지 헤더

- HTTP/1 에서는 헤더 압축기능이 없음
- 헤더 사이즈의 크기는 일부분의 패킷의 저장공간을 차지하기 떄문에 작은 공간의 절약으로 전송 횟수 감소 가능

>>> ### 제한적인 우선순위기능

- HTTP/1 에서는 우선순위 지정 기능이 별도로 존재하지 않음
- HTTP/1 에서 우선순위 지정 기능과 유사한 효과를 보기 위한 방법으로 우선순위가 높은 것부터 순차적으로 요청
- HTTP/1 는 요청 순으로 순차적으로 응답을 받기 때문에 우선순위아 먼저 신청된 개체의 응답 처리가 않되면 다른 후순위 개체들의 처리도 늦어져 전제적으로 출력되는데 시간이 길어질 가능성이 존재

>>> ### 서드파티 개체

- HTTP/1과 HTTP/2 모두 동일하게 발생되고 있는 문제점
- 자사의 제품이 아닌 타사의 서비스를 끌어오는 기능이 웹페이지에 구축되고 있음
  <br /> 대표적인 예로 타사의 API를 끌어오는 현상
- 서드파티로 인한 딜레이 현상을 통제할 방법이 제한적

> ## HTTP/2

- SPDY
  - HTTP/1.1을 보다 효율적으로 개선하기 위한 시도
  - HTTP/2의 탄생 기틀 마련
  - 다중화 (multiplexing), 프레이밍 (framing), 헤더 압축 (header compression) 

- HTTP/2의 목표
  - 최종 사용자의 체감 지연 시간 개선 (TCP 연결)
  - HTTP/1.1의 HOL 해결
  - 병렬처리를 위한 서버 다중연결 제거, TCP 연결로 혼잡제어와 관련된 동작 개선
  - HTTP 메서드, 상태 코드, URI, 헤더 필드 외에도 기존 문서화된 체계 유지 및 활용
  - HTTP/1.X와 HTTP/2와의 호환성유지
  - 새로운 확장 기능과 정책을 적절히 사용하도록 명확히 구성

- HTTP/2 구성 방법
  - 필수는 아니지만 HTTP/2를 구성하기 위해서 SSL/TLS가 필요
    - Let's Encrypt로 TLS 인증서 무료로 사용 가능
    - Let's Encrypt는 Cerbot이라는 클라이언트를 제공하며, 인증서 발급 후 웹서버에 설치까지 모든 요소를 처리하여 발급과 관리절차를 자동화 (도메인 소유권 인증 필요)
    - [참고 링크1](https://github.com/jo116302/Linux/blob/main/Tomcat.md#ssltls)
  - HTTP/2를 지원하는 웹서버 설치

> # 웹 페이지 요청 구조 및 성능

- 개체 요청/반입 흐름도
  <br />![image](https://user-images.githubusercontent.com/81629923/121765542-7e4d8d80-cb86-11eb-9219-d551219f1c3c.png)

- 개체 응답/페이지 렌더링 흐름도
  <br />![image](https://user-images.githubusercontent.com/81629923/121765582-e7cd9c00-cb86-11eb-893e-2fc20707b71c.png)

- 페이징 이벤트가 발생할 때마다 개체 흐름도가 반복적으로 발생하며, 네트워크와 디바이스 자원에 부담

>> ## 성능 측정 요소

- 네트워크
  - [지연시간](https://johngrib.github.io/wiki/latency/)
    - Client의 요청으로부터 IP패킷이 Server까지 요청이 도착하는 시간을 의미
    - RTT(Round-Trip Time) : Client의 요청으로부터 응답을 받는 시간을 의미 (Ping Test의 시간이 대표적인 측정 예시)
  - 대역폭
    - 요청과 응답 사이에서 동시에 처리 가능한 사이즈를 의미
  - DNS 조회
    - 첫 접속할 대상의 DNS와 IP 주소의 맵핑을 위해서 DNS 서버와의 통신하는 시간을 의미
  - 연결 시간
    - 3번의 `Hand Shake` 과정이 필요하며, `Hand Shake`가 이루어지는 시간을 의미
  - TLS 협상 시간
    - `https`를 사용하고 있을 경우, SSL/TLS 협상과정에 발생하는 통신 시간을 의미

- 서버 성능
  - TTFB (Time to First Byte)
    - Client 측에서 요청이 있은 후 첫 응답 데이터(byte)를 수신할 때까지의 시간을 의미
  - Content Download Time
    - 요청 개체에 대한 TTLB를 의미
  - Start Render Time
    - Client가 사용자를 위해 화면을 출력하는 시간을 의미
  - 문서 완성 시간 (Page Load Time)
    - Client가 페이지 출력을 완료하는 시간

- 병목 현상이 증가시키는 새로운 현상
  - 데이터 사이즈 규모
    - 이미지, 동영상, CSS 등의 전송 데이터의 사이즈가 커지면서 로딩이 길어지는 현상 발생
  - 개체 수의 증가
  - 복잡도 증가
    - 다양한 기술이 구현되면서 웹페이지의 복잡도는 증가하였고, 연결 기종간의 성능차이로 구현 고려요소가 많아짐
  - 호스트 수의 증가
    - 웹페이지를 구성할 때 자체적으로 개발한 요소 외에 외부에 요청으로 끌어오는 서비스들을 이용하면서 DNS조회시간, 연결시간, TLS 협상시간이 늘어남
  - TCP 소켓 수의 증가
    - 클라이언트는 호스트마다 여러 개의 소켓 통신을 성립하고, 호스트당 연결 협상 오버헤드 발생 및 디바이스 부하 가중하여 재전송과 버퍼블로트로 인해 실효 대역폭 저하
    - [버퍼블로트 (Bufferbloat)](https://freloha.tistory.com/32) : TCP 통신에서 레이턴시를 줄이기 위해서 통신 복잡도를 제어하기 위한 기술로 `slow start`가 있으며, 데이터 송신 통로를 변화시킨다. `slow start`는 네트워크 장비에서 데이터를 수신하는 장비에서 버퍼가 다 차지 않으면 계속적으로 전송 량을 늘려간다. 기술이 발전한 만큼 버퍼의 크기도 커져 다 소진 및 처리하는데 시간이 걸리며, 데이터(패킷)이 다 차서 추가로 수신되는 데이터를 드랍시키게 되면 다시 전송 속도를 가장 느린 설정 값부터 시작하기 때문에 Client에서는 갑자기 인터넷이 느려졌다 느끼게 되는 현상이다.
      - [참고 링크1](https://evan-moon.github.io/2019/11/26/tcp-congestion-control/)

>> ## 성능 모범사례

- DNS 조회 최적화
  - 고유한 도메인/호스트명의 개수를 제한 (HTTP/2로 넘어갈 경우 성능에 영향이 높음)
  - 서드 파티 등을 포함하여 최종 사용자의 위치에서 레이턴시 측정
  - 초기 HTML이나 응답에 대한 DNS 프리패치 활용
    - HTML을 다운로드하는 동안 페이지 내에 있는 DNS를 조회하는 기능
    - 특정 DNS를 프리패치로 호출하는 방법 : `<link rel="dns-prefetch" href="[DNS]">`

- TCP 연결 최적화
  - TLS 연결이 필요할 경우 TCP 연결 지연시간은 길어지며 이를 해소하기 위한 방법
  - 특정 DNS를 미리 연결을 수립하여 지연시간 감소 : `<link rel="preconnect" href="[URI]" [crossorigin]>`
    - [crossorigin](https://evan-moon.github.io/2020/05/21/about-cors/) : 타 도메인의 ORIGIN 자산을 획득할 수 있음
  - CDN을 사용할 것
  - [TLS 효율적으로 사용 방법](https://istlsfastyet.com/)
  - [외에도 효율적인 link 사용 방법 참고](https://beomy.github.io/tech/browser/preload-preconnect-prefetch/)

- 리다이렉션을 피하라
  - 통상 다른 호스트를 연결하며, 추가적인 연결 수립을 의미하며, 지연시간이 발생
  - 무선 네트워크일 경우 영향이 더 클 수 있음
  - 리다이렉션이 필요할 경우 CDN을 이용하여 Client 내에서 리다이렉션 회피
  - 동일 호스트일 경우 웹 서버에서 `Rewrite Rules`를 사용 ([IIS사용 방법](https://docs.microsoft.com/en-us/iis/extensions/url-rewrite-module/creating-rewrite-rules-for-the-url-rewrite-module), [Apache사용 방법](http://httpd.apache.org/docs/2.4/mod/mod_rewrite.html)

- Client에 Caching
  - 이미지 또는 버전 관리되는 콘텐츠와 같은 정적 콘텐츠는 client로 caching하여 빠른 응답 구현이 가능하도록 구현
  - CSS/JS와 맞춤형 개체는 평균의 Session 시간의 2배 정도로 Caching
  - TTL의 이상 값을 측정 후 적용

- 네트워크 경계에 Caching
  - CDN을 의미하는 것 같음
  - 개인 정보, 금융 정보 등 민감한 데이터는 캐싱 금지
  - 짧은 시간동안 변화가 극심한 실시간 데이터는 캐싱 금지
  - 정적이다 즉시 변화가 필요한 경우 `Hold Until Hold`와 `purging` 매커니즘 활용

- 조건부 캐싱
  - TTL을 조건으로 만료되는 시점에 서버로부터 요청하여 갱신
  - If-Modified-Since HTTP 헤더를 요청에 포함하면, 데이터 갱신된 경우만 콘텐츠 반환하며 갱신이 없는 경우 타임스탬프(DATE)를 포함한 304 응답 반환
  - Caching 된 개체는 고유 ETag가 존재하며 이로 서버와 Caching 데이터 비교

- 압축과 축소화
  - HTML, JS, CSS, SVG, XML, JSON, FONT 등은 압축과 축소화로 데이터 다이어트 가능

> # 참고 링크

1) [책 내용 링크(Learning HTTP/2)](https://yuchae.tistory.com/364?category=322306)
2) [Google Developer](https://developers.google.com/web/fundamentals/performance/http2?hl=ko#spdy_%EB%B0%8F_http2%EC%9D%98_%EA%B0%84%EB%9E%B5%ED%95%9C_%EC%97%AD%EC%82%AC)
3) [참고 링크1](https://www.whatap.io/ko/blog/38/)
4) [참고 링크2](https://velog.io/@taesunny/HTTP2HTTP-2.0-%EC%A0%95%EB%A6%AC)
5) [참고 링크3](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview)
6) [참고 링크4](https://protocol.knu.ac.kr/tech/CPL-TR-09-03-LNP.pdf)
7) [참고 링크5](https://ijbgo.tistory.com/?page=3)
8) [참고 링크6](https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x)
