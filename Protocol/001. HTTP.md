> # HTTP/1

- 하이퍼텍스트
  - 제약 없는 방식으로 서로 연결되어 사람이 읽을 수 있는 정보를 의미
  - 정보가 반드시 텍스트 형태일 필요는 없음을 의미

>> ## HTTP/0.9 

- GET 하나의 메서드만 존재
- 헤더가 없음
- 텍스트만 처리 가능

>> ## HTTP/1.0

- HTTP/0.9 보다 추가된 기능
  - Header
  - Response codes (응답 코드)
  - Redirect (리다이렉트)
  - Error (오류)
  - Conditional requests (조건부 요청)
  - Encoding (콘텐츠 인코딩), (Compression (압축))
  - Request Method (다양해진 요청 메서드 존재)

- 한계점
  - Header 필수가 아님
  - 지속적인 요청사이에 연결 유지 기능이 없음
  - 캐싱 옵션 빈약

>> ## HTTP/1.1

- 20년 넘게 명맥을 유지해왔음
- HTTP/1.0 보다 개선 또는 추가된 기능
  - Header 필수 항목 - 하나의 IP 주소로 다수의 웹 프로퍼티 제공 가능
  - 새 연결 지시자를 사용하면 웹 서버는 응답 후 연결 유지 가능 (TCP 연결을 유지할 수 있어 재수립 시간 절약 및 성능 향상)
  - Cacheability 헤더의 확장
  - OPTIONS 메서드
  - Upgrade 헤더
  - Range 요청
  - Transfer-Encoding 압축
  - 파이프라이닝
    - 클라이언트의 요청을 동시에 전송 가능 기술
    - 문제점
      - 순서대로 응답
      - 한 요청이 장시간 처리가 필요한 경우 HOL (Head Of Line Blocking) 현상 발생

>> ## HTTP/1의 부각되는 문제점

>>> ### [HOL 블로킹](https://withbundo.blogspot.com/2021/02/httphol-head-of-line-blocking.html)

- 통신 시간을 줄이기 위한 병렬적인 요청 및 응답을 구현하려고 HTTP/1에서 Pipelining 이라는 기능 사용
- 하지만 결과적으로는 한번에 하나의 응답을 전송 순으로 수신
- 가장 먼저 받아야될 응답의 딜레이가 발생한다면 후순위 응답을 받지 못하는 현상을 의미
- [다른 측면으로서의 HOL Blocking](https://zigispace.net/970)

> ## HTTP/2

- SPDY
  - HTTP/1.1을 보다 효율적으로 개선하기 위한 시도
  - HTTP/2의 탄생 기틀 마련
  - 다중화 (multiplexing), 프레이밍 (framing), 헤더 압축 (header compression) 

- HTTP/2의 목표
  - 최종 사용자의 체감 지연 시간 개선 (TCP 연결)
  - HTTP/1.1의 HOL 해결
  - 병렬처리를 위한 서버 다중연결 제거, TCP 연결로 혼잡제어와 관련된 동작 개선
  - HTTP 메서드, 상태 코드, URI, 헤더 필드 외에도 기존 문서화된 체계 유지 및 활용
  - HTTP/1.X와 HTTP/2와의 호환성유지
  - 새로운 확장 기능과 정책을 적절히 사용하도록 명확히 구성

- HTTP/2 구성 방법
  - 필수는 아니지만 HTTP/2를 구성하기 위해서 SSL/TLS가 필요
    - Let's Encrypt로 TLS 인증서 무료로 사용 가능
    - Let's Encrypt는 Cerbot이라는 클라이언트를 제공하며, 인증서 발급 후 웹서버에 설치까지 모든 요소를 처리하여 발급과 관리절차를 자동화 (도메인 소유권 인증 필요)
    - [참고 링크1](https://github.com/jo116302/Linux/blob/main/Tomcat.md#ssltls)
  - HTTP/2를 지원하는 웹서버 설치

> # 웹 페이지 요청 구조

- 개체 요청/반입 흐름도
  <br />![image](https://user-images.githubusercontent.com/81629923/121765542-7e4d8d80-cb86-11eb-9219-d551219f1c3c.png)

- 개체 응답/페이지 렌더링 흐름도
  <br />![image](https://user-images.githubusercontent.com/81629923/121765582-e7cd9c00-cb86-11eb-893e-2fc20707b71c.png)

- 페이징 이벤트가 발생할 때마다 개체 흐름도가 반복적으로 발생하며, 네트워크와 디바이스 자원에 부담

>> ## 성능 측정 요소

- 네트워크
  - [지연시간](https://johngrib.github.io/wiki/latency/)
    - Client의 요청으로부터 IP패킷이 Server까지 요청이 도착하는 시간을 의미
    - RTT(Round-Trip Time) : Client의 요청으로부터 응답을 받는 시간을 의미 (Ping Test의 시간이 대표적인 측정 예시)
  - 대역폭
    - 요청과 응답 사이에서 동시에 처리 가능한 사이즈를 의미
  - DNS 조회
    - 첫 접속할 대상의 DNS와 IP 주소의 맵핑을 위해서 DNS 서버와의 통신하는 시간을 의미
  - 연결 시간
    - 3번의 `Hand Shake` 과정이 필요하며, `Hand Shake`가 이루어지는 시간을 의미
  - TLS 협상 시간
    - `https`를 사용하고 있을 경우, SSL/TLS 협상과정에 발생하는 통신 시간을 의미

- 서버 성능
  - TTFB (Time to First Byte)
    - Client 측에서 요청이 있은 후 첫 응답 데이터(byte)를 수신할 때까지의 시간을 의미
  - Content Download Time
    - 요청 개체에 대한 TTLB를 의미
  - Start Render Time
    - Client가 사용자를 위해 화면을 출력하는 시간을 의미
  - 문서 완성 시간 (Page Load Time)
    - Client가 페이지 출력을 완료하는 시간

- 병목 현상이 증가시키는 새로운 현상
  - 데이터 사이즈 규모
    - 이미지, 동영상, CSS 등의 전송 데이터의 사이즈가 커지면서 로딩이 길어지는 현상 발생
  - 개체 수의 증가
  - 복잡도 증가
    - 다양한 기술이 구현되면서 웹페이지의 복잡도는 증가하였고, 연결 기종간의 성능차이로 구현 고려요소가 많아짐
  - 호스트 수의 증가
    - 웹페이지를 구성할 때 자체적으로 개발한 요소 외에 외부에 요청으로 끌어오는 서비스들을 이용하면서 DNS조회시간, 연결시간, TLS 협상시간이 늘어남
  - TCP 소켓 수의 증가
    - 클라이언트는 호스트마다 여러 개의 소켓 통신을 성립하고, 호스트당 연결 협상 오버헤드 발생 및 디바이스 부하 가중하여 재전송과 버퍼블로트로 인해 실효 대역폭 저하
    - [버퍼블로트 (Bufferbloat)](https://freloha.tistory.com/32) : TCP 통신에서 레이턴시를 줄이기 위해서 통신 복잡도를 제어하기 위한 기술로 `slow start`가 있으며, 데이터 송신 통로를 변화시킨다. `slow start`는 네트워크 장비에서 데이터를 수신하는 장비에서 버퍼가 다 차지 않으면 계속적으로 전송 량을 늘려간다. 기술이 발전한 만큼 버퍼의 크기도 커져 다 소진 및 처리하는데 시간이 걸리며, 데이터(패킷)이 다 차서 추가로 수신되는 데이터를 드랍시키게 되면 다시 전송 속도를 가장 느린 설정 값부터 시작하기 때문에 Client에서는 갑자기 인터넷이 느려졌다 느끼게 되는 현상이다.
      - [참고 링크1](https://evan-moon.github.io/2019/11/26/tcp-congestion-control/)


> # 참고 링크

1) [책 내용 링크(Learning HTTP/2)](https://yuchae.tistory.com/364?category=322306)
2) [Google Developer](https://developers.google.com/web/fundamentals/performance/http2?hl=ko#spdy_%EB%B0%8F_http2%EC%9D%98_%EA%B0%84%EB%9E%B5%ED%95%9C_%EC%97%AD%EC%82%AC)
3) [참고 링크1](https://www.whatap.io/ko/blog/38/)
4) [참고 링크2](https://velog.io/@taesunny/HTTP2HTTP-2.0-%EC%A0%95%EB%A6%AC)
5) [참고 링크3](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview)
6) [참고 링크4](https://protocol.knu.ac.kr/tech/CPL-TR-09-03-LNP.pdf)
7) [참고 링크5](https://ijbgo.tistory.com/?page=3)
